---
layout: post
title: CS50x 02 - C
categories:
    - CS50x
tags:
    - CS
---

## Hello World

```c
#include <stdio.h>

int main(void){
    printf("Hello, world\n");
}
```

-------

## C的数据类型

| 类型  | 描述  |
| --- | --- |
| 基本类型 | 是算术类型，包括两种类型：整数类型和浮点类型。 |
| 枚举类型 | 也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 |
| void类型 | 类型说明符 void 表明没有可用的值。 |
| 派生类型 | 包括：指针类型、数组类型、结构类型、共用体类型和函数类型。 |

### 整数类型

| 类型  | 存储大小 | 值范围 |
| --- | --- | --- |
| char | 1 字节 | -128 到 127 或 0 到 255 |
| unsigned char | 1 字节 | 0 到 255 |
| signed char | 1 字节 | -128 到 127 |
| int | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295 |
| short | 2 字节 | -32,768 到 32,767 |
| unsigned short | 2 字节 | 0 到 65,535 |
| long | 4 字节 | -2,147,483,648 到 2,147,483,647 |
| unsigned long | 4 字节 | 0 到 4,294,967,295 |

#### Int

整数型，占用4字节（32比特），可存储的数为-2,147,483,648 到 2,147,483,647。

#### unsigned int

无符号的整数型，可存储的数为0 到 4,294,967,295。

#### char

单个字符，占用1字节（8比特）

### 浮点类型

| 类型  | 存储大小 | 值范围 | 精度  |
| --- | --- | --- | --- |
| float | 4 字节 | 1.2E-38 到 3.4E+38 | 6 位有效位 |
| double | 8 字节 | 2.3E-308 到 1.7E+308 | 15 位有效位 |
| long double | 16 字节 | 3.4E-4932 到 1.1E+4932 | 19 位有效位 |

单精度，也即float，一般在计算机中存储占用4字节，也32位，有效位数为7位；单精度是这样的格式，1位符号，8位指数，23位小数。

![](https://pica.zhimg.com/80/v2-749cc641eb4d5dafd085e8c23f8826aa_720w.jpg?source=1940ef5c)

双精度（double）在计算机中存储占用8字节，64位，有效位数为16位。双精度是1位符号，11位指数，52位小数。

![](https://pic2.zhimg.com/80/v2-48240f0e1e0dd33ec89100cbe2d30707_720w.jpg?source=1940ef5c)

### void 类型

void 类型指定没有可用的值。它通常用于以下三种情况下：

| 序号  | 类型与描述 |
| --- | --- |
| 1   | 函数返回为空。例如 `void exit (int status)` |
| 2   | 函数参数为空。不带参数的函数可以接受一个 void。例如`int rand(void)` |
| 3   | 指针指向 void。类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 `void *malloc( size_t size )` 返回指向 void 的指针，可以转换为任何数据类型。 |

### 数据类型转换

如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型；在 C 语言中也可以对数据类型进行强制转换。

#### 自动转换

- 浮点数赋给整型，该浮点数小数被舍去。
  
- 整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中。
  

#### 强制类型转换

`(类型说明符)(表达式)`

例如：

```c
#include<stdio.h>

int main()
{
    float f,x=3.6,y=5.2;
    int i=4,a,b;
    a=x+y;
    b=(int)(x+y);
    f=10/i;
    printf("a=%d,b=%d,f=%f,x=%f\n",a,b,f,x);
}
```

例中先计算 x+y 值为 8.8，然后赋值给 a，因为a为整型，所以自取整数部分8，a=8;

接下来 b 把 x+y 强制转换为整型;

最后 10/i 是两个整数相除，结果仍为整数 2，把 2 赋给浮点数 f;

x 为浮点型直接输出。

-------

## 运算符

### 算术运算符

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述  | 实例  |
| --- | --- | --- |
| +   | 把两个操作数相加 | A + B 将得到 30 |
| -   | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |
| *   | 把两个操作数相乘 | A * B 将得到 200 |
| /   | 分子除以分母 | B / A 将得到 2 |
| %   | 取模运算符，整除后的余数 | B % A 将得到 0 |
| ++  | 自增运算符，整数值增加 1 | A++ 将得到 11 |
| --  | 自减运算符，整数值减少 1 | A-- 将得到 9 |

`i++`和`++i`的区别在于：前者先传递i的值，再自增；后者先自增，再传递i的值。

### 关系运算符

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述  | 实例  |
| --- | --- | --- |
| ==  | 检查两个操作数的值是否相等，如果相等则条件为真。 | (A == B) 为假。 |
| !=  | 检查两个操作数的值是否相等，如果不相等则条件为真。 | (A != B) 为真。 |
| >   | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 | (A > B) 为假。 |
| <   | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 | (A < B) 为真。 |
| >=  | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 为假。 |
| <=  | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。 |

### 逻辑运算符

假设变量 A 的值为 1，变量 B 的值为 0，则：

| 运算符 | 描述  | 实例  |
| --- | --- | --- |
| &&  | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 | (A && B) 为假。 |
| \\|\\| | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A \\|\\| B) 为真。 |
| !   | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。 |

### 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p   | q   | p & q | p \\| q | p ^ q |
| --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   |
| 0   | 1   | 0   | 1   | 1   |
| 1   | 1   | 1   | 1   | 0   |
| 1   | 0   | 0   | 1   | 1   |

此外，还有：

<<：二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。

\>>：二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。

### 赋值运算符

| 运算符 | 描述  | 实例  |
| --- | --- | --- |
| =   | 简单的赋值运算符，把右边操作数的值赋给左边操作数 | C = A + B 将把 A + B 的值赋给 C |
| +=  | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A |
| -=  | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A |
| *=  | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A |
| /=  | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A |
| %=  | 求模且赋值运算符，求两个操作数的模赋值给左边操作数 | C %= A 相当于 C = C % A |
| <<= | 左移且赋值运算符 | C <<= 2 等同于 C = C << 2 |
| >>= | 右移且赋值运算符 | C >>= 2 等同于 C = C >> 2 |
| &=  | 按位与且赋值运算符 | C &= 2 等同于 C = C & 2 |
| ^=  | 按位异或且赋值运算符 | C ^= 2 等同于 C = C ^ 2 |
| \\|= | 按位或且赋值运算符 | C \\|= 2 等同于 C = C \\| 2 |

### 其他运算符

| 运算符 | 描述  | 实例  |
| --- | --- | --- |
| sizeof() | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。 |
| &   | 返回变量的地址。 | &a; 将给出变量的实际地址。 |
| *   | 指向一个变量。 | *a; 将指向一个变量。 |
| ? : | 条件表达式 | 如果条件为真 ? 则值为 X : 否则值为 Y |

### 运算符优先级

按运算符优先级从高到低列出各个运算符

| 类别  | 运算符 | 结合性 |
| --- | --- | --- |
| 后缀  | () [] -> . ++ - - | 从左到右 |
| 一元  | + - ! ~ ++ - - (type)* & sizeof | 从右到左 |
| 乘除  | * / % | 从左到右 |
| 加减  | + - | 从左到右 |
| 移位  | << >> | 从左到右 |
| 关系  | < <= > >= | 从左到右 |
| 相等  | == != | 从左到右 |
| 位与 AND | &   | 从左到右 |
| 位异或 XOR | ^   | 从左到右 |
| 位或 OR | \\| | 从左到右 |
| 逻辑与 AND | &&  | 从左到右 |
| 逻辑或 OR | \\|\\| | 从左到右 |
| 条件  | ?:  | 从右到左 |
| 赋值  | = += -= *= /= %=>>= <<= &= ^= \\|= | 从右到左 |
| 逗号  | ,   | 从左到右 |

---------

## 判断

### if... else...

```c
if (boolean_expression_1)
{
    //执行语句1
}
else if (boolean_expression_2)
{
    //执行语句2
}
else
{
    //执行语句3
}
```

### switch

一个switch语句允许测试一个变量等于多个值时的情况。每个值称为一个 case。

```c
switch(expression){
    case constant-expression  :
       statement(s);
       break; /* 可选的 */
    case constant-expression  :
       statement(s);
       break; /* 可选的 */

    /* 您可以有任意数量的 case 语句 */
    default : /* 可选的 */
       statement(s);
}
```

switch语句必须遵循下面的规则：

- **switch** 语句中的 **expression** 是一个常量表达式，必须是一个整型或枚举类型。
- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 *继续* 后续的 case，直到遇到 break 为止。
- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。

### 三元运算符 ?:

可以用来替代 if...else语句。例如，判断一个数为奇数还是偶数：

```c
#include<stdio.h>

int main()
{
    int num;

    printf("输入一个数字 : ");
    scanf("%d",&num);

    (num%2==0)?printf("偶数"):printf("奇数");
}
```

-------

## 循环

| 循环类型 | 描述  |
| --- | --- |
| while 循环 | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |
| for 循环 | 多次执行一个语句序列，简化管理循环变量的代码。 |
| do...while 循环 | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 |
| 嵌套循环 | 在 while、for 或 do..while 循环内使用一个或多个循环。 |

### while循环

只要给定的条件为真，C 语言中的 **while** 循环语句会重复执行一个目标语句。

```c
while(condition)
{
   statement(s);
}
```

while循环可能一次都不会执行。当条件为 false 时，会跳过循环主体，直接执行紧接着 while 循环的下一条语句。

### for循环

指定循环次数。for循环也可能一次都不执行。

```c
for ( init; condition; increment )
{
   statement(s);
}
```

1. **init** 会首先被执行，且只会执行一次。这里可以声明并初始化循环控制变量。也可以不写任何语句，只要有一个分号出现即可。
2. 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
3. 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句可以留空，只要在条件后有一个分号出现即可。
4. 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。

### do循环

至少执行一次的循环。

```c
do
{
   statement(s);

}while( condition );
```

### 循环控制语句

| 控制语句 | 描述  |
| --- | --- |
| break | 终止**循环**或 **switch** 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。 |
| continue | 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。 |
| goto 语句 | 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 |